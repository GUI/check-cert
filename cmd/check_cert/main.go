// Copyright 2020 Adam Chalkley
//
// https://github.com/atc0005/check-cert
//
// Licensed under the MIT License. See LICENSE file in the project root for
// full license information.

package main

import (
	"crypto/tls"
	"errors"
	"fmt"
	"net"
	"strings"
	"time"

	zlog "github.com/rs/zerolog/log"

	"github.com/atc0005/check-certs/internal/certs"
	"github.com/atc0005/check-certs/internal/config"
	"github.com/atc0005/go-nagios"
)

func main() {

	// Set initial "state" as valid, adjust as we go.
	var nagiosExitState = nagios.ExitState{
		LastError:      nil,
		ExitStatusCode: nagios.StateOKExitCode,
	}

	// defer this from the start so it is the last deferred function to run
	defer nagiosExitState.ReturnCheckResults()

	// Setup configuration by parsing user-provided flags.
	isPlugin := true
	cfg, cfgErr := config.New(isPlugin)
	switch {
	case errors.Is(cfgErr, config.ErrVersionRequested):
		fmt.Println(config.Version())

		return

	case cfgErr != nil:
		// We're using the standalone Err function from rs/zerolog/log as we
		// do not have a working configuration.
		zlog.Err(cfgErr).Msg("Error initializing application")
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error initializing application",
			nagios.StateCRITICALLabel,
		)
		nagiosExitState.LastError = cfgErr
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode

		return
	}

	if cfg.EmitBranding {
		// If enabled, show application details at end of notification
		nagiosExitState.BrandingCallback = config.Branding("Notification generated by ")
	}

	// Use provided threshold values to calculate the expiration times that
	// should trigger either a WARNING or CRITICAL state.
	now := time.Now().UTC()
	certsExpireAgeWarning := now.AddDate(0, 0, cfg.AgeWarning)
	certsExpireAgeCritical := now.AddDate(0, 0, cfg.AgeCritical)

	nagiosExitState.WarningThreshold = fmt.Sprintf(
		"Expires before %v (%d days)",
		certsExpireAgeWarning.Format(certs.CertValidityDateLayout),
		cfg.AgeWarning,
	)
	nagiosExitState.CriticalThreshold = fmt.Sprintf(
		"Expires before %v (%d days)",
		certsExpireAgeCritical.Format(certs.CertValidityDateLayout),
		cfg.AgeCritical,
	)

	log := cfg.Log.With().
		Str("expected_sans_entries", cfg.SANsEntries.String()).
		Logger()

	server := fmt.Sprintf("%s:%d", cfg.Server, cfg.Port)

	log.Debug().Msg("Connecting to remote server")
	tlsConfig := tls.Config{
		// Allow insecure connection so that we can check not only the initial
		// certificate (which may be expired), but others in the chain also to
		// potentially catch any intermediates which may also be expired.
		// Also, ignore security (gosec) linting warnings re this choice.
		// nolint:gosec
		InsecureSkipVerify: true,
	}

	// Create custom dialer with user-specified timeout value
	dialer := &net.Dialer{
		Timeout: time.Duration(cfg.Timeout) * time.Second,
	}

	conn, connErr := tls.DialWithDialer(dialer, "tcp", server, &tlsConfig)
	if connErr != nil {
		nagiosExitState.LastError = connErr
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: Error connecting to %s",
			nagios.StateCRITICALLabel,
			server,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
		log.Error().Err(connErr).Msg("error connecting to server")

		// no need to go any further, we *want* to exit right away; we don't
		// have a connection to the remote server and there isn't anything
		// further we can do
		return
	}
	defer func() {
		if err := conn.Close(); err != nil {
			log.Error().Err(err).Msgf("error closing connection to server")
		}
	}()
	log.Debug().Msg("Connected")

	// certificate chain presented by remote peer
	certChain := conn.ConnectionState().PeerCertificates

	certsSummary := certs.ChainSummary(
		certChain,
		certsExpireAgeCritical,
		certsExpireAgeWarning,
	)

	// NOTE: Not sure this would ever be reached due to expectations of
	// tls.Dial() that a certificate is present for the connection
	if certsSummary.TotalCertsCount == 0 {
		noCertsErr := fmt.Errorf("no certificates found")
		nagiosExitState.LastError = noCertsErr
		nagiosExitState.ServiceOutput = fmt.Sprintf(
			"%s: 0 certificates found at %q",
			nagios.StateCRITICALLabel,
			server,
		)
		nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
		log.Error().Err(noCertsErr).Msg("no certificates found")

		return
	}

	if certsSummary.TotalCertsCount > 0 {

		hostnameValue := cfg.Server

		// Allow user to explicitly specify which hostname should be used
		// for comparison against the leaf certificate.
		if cfg.DNSName != "" {
			hostnameValue = cfg.DNSName
		}

		// Verify leaf certificate is valid for the provided server FQDN; we
		// make the assumption that the leaf certificate is ALWAYS in position
		// 0 of the chain. Not having the cert in that position is treated as
		// an error condition.
		//
		// Server Name Indication (SNI) support is used to provide the value
		// specified by the `server` flag to the remote server. This is less
		// important for remote hosts with only one certificate, but for a
		// host with multiple certificates it becomes very important to
		// provide the sitename as the value to the `server` flag so that the
		// correct certificate for the connection can be provided.
		if err := certChain[0].VerifyHostname(hostnameValue); err != nil {
			nagiosExitState.LastError = err
			nagiosExitState.ServiceOutput = fmt.Sprintf(
				"hostname %q does not match first cert in chain %q",
				hostnameValue,
				certChain[0].Subject.CommonName,
			)
			nagiosExitState.LongServiceOutput =
				"Consider updating the service check or command " +
					"definition to specify the website FQDN instead of " +
					"the host FQDN as the 'server' flag value. " +
					"E.g., use 'www.example.org' instead of " +
					"'host7.example.com' in order to allow the remote " +
					"server to select the correct certificate instead " +
					"of the certificate for the first website in its list."

			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
			log.Error().
				Err(err).
				Str("hostname", hostnameValue).
				Str("cert_cn", certChain[0].Subject.CommonName).
				Str("sans_entries", fmt.Sprintf("%s", certChain[0].DNSNames)).
				Msg("hostname does not match first cert in chain")

			return

		}

		log.Debug().
			Str("hostname", hostnameValue).
			Str("cert_cn", certChain[0].Subject.CommonName).
			Msg("provided hostname %q matches server certificate")

	}

	// check SANS entries if provided via command-line
	if len(cfg.SANsEntries) > 0 {

		// Check for special keyword, skip SANs entry checks if provided
		firstSANsEntry := strings.ToLower(strings.TrimSpace(cfg.SANsEntries[0]))
		if firstSANsEntry != strings.ToLower(strings.TrimSpace(config.SkipSANSCheckKeyword)) {

			if mismatched, err := certs.CheckSANsEntries(certChain[0], certChain, cfg.SANsEntries); err != nil {

				nagiosExitState.LastError = err

				nagiosExitState.LongServiceOutput = certs.GenerateCertsReport(
					certChain,
					certsExpireAgeCritical,
					certsExpireAgeWarning,
				)

				nagiosExitState.ServiceOutput = fmt.Sprintf(
					"%s: Mismatch of %d SANs entries for certificate %q",
					nagios.StateCRITICALLabel,
					mismatched,
					cfg.Server,
				)

				nagiosExitState.ExitStatusCode = nagios.StateWARNINGExitCode
				log.Warn().
					Err(nagiosExitState.LastError).
					Int("sans_entries_requested", len(cfg.SANsEntries)).
					Int("sans_entries_found", len(certChain)).
					Msg("SANs entries mismatch")

				return

			}
		}
	}

	if certsSummary.HasExpiredCerts || certsSummary.HasExpiringCerts {

		nagiosExitState.LastError = fmt.Errorf(
			"%d certificates expired or expiring",
			certsSummary.ExpiredCertsCount+certsSummary.ExpiringCertsCount,
		)
		nagiosExitState.LongServiceOutput = certs.GenerateCertsReport(
			certChain,
			certsExpireAgeCritical,
			certsExpireAgeWarning,
		)

		if certsSummary.HasExpiringCerts {

			nagiosExitState.ServiceOutput = certs.OneLineCheckSummary(
				nagios.StateWARNINGLabel,
				certChain,
				certsSummary.Summary,
			)

			nagiosExitState.ExitStatusCode = nagios.StateWARNINGExitCode
			log.Warn().
				Err(nagiosExitState.LastError).
				Int("expiring_certs", certsSummary.ExpiringCertsCount).
				Msg("expiring certs present in chain")
		}

		// intentionally overwrite/override "warning" status from the last
		// check; expired certs are more of a concern than expiring certs
		if certsSummary.HasExpiredCerts {
			nagiosExitState.ServiceOutput = certs.OneLineCheckSummary(
				nagios.StateCRITICALLabel,
				certChain,
				certsSummary.Summary,
			)
			nagiosExitState.ExitStatusCode = nagios.StateCRITICALExitCode
			log.Error().
				Err(nagiosExitState.LastError).
				Int("expired_certs", certsSummary.ExpiredCertsCount).
				Msg("expired certs present in chain")
		}

		return

	}

	nagiosExitState.LastError = nil

	nagiosExitState.ServiceOutput = certs.OneLineCheckSummary(
		nagios.StateOKLabel,
		certChain,
		certsSummary.Summary,
	)

	nagiosExitState.LongServiceOutput = certs.GenerateCertsReport(
		certChain,
		certsExpireAgeCritical,
		certsExpireAgeWarning,
	)
	nagiosExitState.ExitStatusCode = nagios.StateOKExitCode
	log.Debug().Msg("No problems with certificate chain detected")

	// defer is still needed here to allow other deferred function calls to run

}
